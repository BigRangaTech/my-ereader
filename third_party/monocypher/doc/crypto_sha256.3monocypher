.\" This file is dual-licensed.  Choose whichever you want.
.\"
.\" The first licence is a regular 2-clause BSD licence.  The second licence
.\" is the CC-0 from Creative Commons. It is intended to release Monocypher
.\" to the public domain.  The BSD licence serves as a fallback option.
.\"
.\" SPDX-License-Identifier: BSD-2-Clause OR CC0-1.0
.\"
.\" ----------------------------------------------------------------------------
.\"
.\" Copyright (c) 2026
.\" All rights reserved.
.\"
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions are
.\" met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\"
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the
.\"    distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\" ----------------------------------------------------------------------------
.\"
.\" Written in 2026.
.\"
.\" To the extent possible under law, the author(s) have dedicated all copyright
.\" and related neighboring rights to this software to the public domain
.\" worldwide.  This software is distributed without any warranty.
.\"
.\" You should have received a copy of the CC0 Public Domain Dedication along
.\" with this software.  If not, see
.\" <https://creativecommons.org/publicdomain/zero/1.0/>
.\"
.Dd February 1, 2026
.Dt CRYPTO_SHA256 3MONOCYPHER
.Os
.Sh NAME
.Nm crypto_sha256 ,
.Nm crypto_sha256_init ,
.Nm crypto_sha256_update ,
.Nm crypto_sha256_final ,
.Nm crypto_sha256_hmac ,
.Nm crypto_sha256_hmac_init ,
.Nm crypto_sha256_hmac_update ,
.Nm crypto_sha256_hmac_final ,
.Nm crypto_sha256_hkdf ,
.Nm crypto_sha256_hkdf_expand ,
.Nm crypto_sha256_checked ,
.Nm crypto_sha256_hmac_checked ,
.Nm crypto_sha256_hkdf_checked ,
.Nm crypto_sha256_hkdf_expand_checked ,
.Nm crypto_sha256_init_checked ,
.Nm crypto_sha256_update_checked ,
.Nm crypto_sha256_final_checked ,
.Nm crypto_sha256_hmac_init_checked ,
.Nm crypto_sha256_hmac_update_checked ,
.Nm crypto_sha256_hmac_final_checked
.Nd hashing, message authentication, and key derivation with SHA-256
.Sh SYNOPSIS
.In monocypher.h
.Ft void
.Fo crypto_sha256
.Fa "uint8_t hash[32]"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft void
.Fo crypto_sha256_init
.Fa "crypto_sha256_ctx *ctx"
.Fc
.Ft void
.Fo crypto_sha256_update
.Fa "crypto_sha256_ctx *ctx"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft void
.Fo crypto_sha256_final
.Fa "crypto_sha256_ctx *ctx"
.Fa "uint8_t hash[32]"
.Fc
.Ft void
.Fo crypto_sha256_hmac
.Fa "uint8_t hmac[32]"
.Fa "const uint8_t *key"
.Fa "size_t key_size"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft void
.Fo crypto_sha256_hmac_init
.Fa "crypto_sha256_hmac_ctx *ctx"
.Fa "const uint8_t *key"
.Fa "size_t key_size"
.Fc
.Ft void
.Fo crypto_sha256_hmac_update
.Fa "crypto_sha256_hmac_ctx *ctx"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft void
.Fo crypto_sha256_hmac_final
.Fa "crypto_sha256_hmac_ctx *ctx"
.Fa "uint8_t hmac[32]"
.Fc
.Ft void
.Fo crypto_sha256_hkdf
.Fa "uint8_t *okm"
.Fa "size_t okm_size"
.Fa "const uint8_t *ikm"
.Fa "size_t ikm_size"
.Fa "const uint8_t *salt"
.Fa "size_t salt_size"
.Fa "const uint8_t *info"
.Fa "size_t info_size"
.Fc
.Ft void
.Fo crypto_sha256_hkdf_expand
.Fa "uint8_t *okm"
.Fa "size_t okm_size"
.Fa "const uint8_t *prk"
.Fa "size_t prk_size"
.Fa "const uint8_t *info"
.Fa "size_t info_size"
.Fc
.Ft int
.Fo crypto_sha256_checked
.Fa "uint8_t hash[32]"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft int
.Fo crypto_sha256_hmac_checked
.Fa "uint8_t hmac[32]"
.Fa "const uint8_t *key"
.Fa "size_t key_size"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft int
.Fo crypto_sha256_hkdf_checked
.Fa "uint8_t *okm"
.Fa "size_t okm_size"
.Fa "const uint8_t *ikm"
.Fa "size_t ikm_size"
.Fa "const uint8_t *salt"
.Fa "size_t salt_size"
.Fa "const uint8_t *info"
.Fa "size_t info_size"
.Fc
.Ft int
.Fo crypto_sha256_hkdf_expand_checked
.Fa "uint8_t *okm"
.Fa "size_t okm_size"
.Fa "const uint8_t *prk"
.Fa "size_t prk_size"
.Fa "const uint8_t *info"
.Fa "size_t info_size"
.Fc
.Ft int
.Fo crypto_sha256_init_checked
.Fa "crypto_sha256_ctx *ctx"
.Fc
.Ft int
.Fo crypto_sha256_update_checked
.Fa "crypto_sha256_ctx *ctx"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft int
.Fo crypto_sha256_final_checked
.Fa "crypto_sha256_ctx *ctx"
.Fa "uint8_t hash[32]"
.Fc
.Ft int
.Fo crypto_sha256_hmac_init_checked
.Fa "crypto_sha256_hmac_ctx *ctx"
.Fa "const uint8_t *key"
.Fa "size_t key_size"
.Fc
.Ft int
.Fo crypto_sha256_hmac_update_checked
.Fa "crypto_sha256_hmac_ctx *ctx"
.Fa "const uint8_t *message"
.Fa "size_t message_size"
.Fc
.Ft int
.Fo crypto_sha256_hmac_final_checked
.Fa "crypto_sha256_hmac_ctx *ctx"
.Fa "uint8_t hmac[32]"
.Fc
.Sh DESCRIPTION
.Ss Hashing
.Fn crypto_sha256 ,
.Fn crypto_sha256_init ,
.Fn crypto_sha256_update ,
and
.Fn crypto_sha256_final
implement SHA-256.
They are provided to enable compatibility with other cryptographic
systems.
For new designs, prefer
.Xr crypto_blake2b 3monocypher
or
.Xr crypto_blake3 3monocypher .
.Pp
SHA-256 is
.Em vulnerable to length extension attacks ,
and thus cannot directly be used for message authentication codes (MAC),
nor as a random oracle.
For those, use the
.Fn crypto_sha256_hmac
family of functions instead.
.Ss Message authentication codes
.Fn crypto_sha256_hmac ,
.Fn crypto_sha256_hmac_init ,
.Fn crypto_sha256_hmac_update ,
and
.Fn crypto_sha256_hmac_final
implement HMAC with SHA-256.
.Ss HKDF
.Fn crypto_sha256_hkdf
and
.Fn crypto_sha256_hkdf_expand
implement HKDF-SHA256.
.Ss Incremental interface
The incremental interface is useful for streaming large inputs without
buffering them in memory.
.Fn crypto_sha256_init
initialises a context.
.Fn crypto_sha256_update
processes message chunks.
.Fn crypto_sha256_final
produces the final hash and wipes the context.
.Pp
For application code, prefer the checked variants.
They validate sizes and pointers and return explicit error codes.
.Sh RETURN VALUES
The unchecked variants return nothing.
The checked variants return:
.Bl -tag -width Ds
.It Dv CRYPTO_OK
The operation completed successfully.
.It Dv CRYPTO_ERR_NULL
One or more pointers were
.Dv NULL .
.It Dv CRYPTO_ERR_SIZE
The output length is too large for HKDF
(applies to
.Fn crypto_sha256_hkdf_checked
and
.Fn crypto_sha256_hkdf_expand_checked ) .
.El
.Sh EXAMPLES
Hashing a message all at once:
.Bd -literal -offset indent
uint8_t hash   [32]; /* Output hash (32 bytes)          */
uint8_t message[12] = "Lorem ipsum"; /* Message to hash */
if (crypto_sha256_checked(hash, message, 12) != CRYPTO_OK) {
	/* Abort on invalid inputs */
}
.Ed
.Pp
Hashing a message incrementally:
.Bd -literal -offset indent
uint8_t hash   [32]; /* Output hash (32 bytes) */
uint8_t message[500] = {1}; /* Message to hash */
crypto_sha256_ctx ctx;
if (crypto_sha256_init_checked(&ctx) != CRYPTO_OK) {
	/* Abort on invalid inputs */
}
for (size_t i = 0; i < 500; i += 100) {
	if (crypto_sha256_update_checked(&ctx, message + i, 100) != CRYPTO_OK) {
		/* Abort on invalid inputs */
	}
}
if (crypto_sha256_final_checked(&ctx, hash) != CRYPTO_OK) {
	/* Abort on invalid inputs */
}
.Ed
.Pp
Computing a message authentication code all at once:
.Bd -literal -offset indent
uint8_t hmac   [32];                /* Output HMAC            */
uint8_t key    [32];                /* Key                    */
uint8_t message[10] = "Lorem ipsu"; /* Message to authenticate */
crypto_random(key, 32);
if (crypto_sha256_hmac_checked(hmac, key, 32, message, 10) != CRYPTO_OK) {
	/* Abort on invalid inputs */
}
crypto_wipe(message, 10);
crypto_wipe(key, 32);
.Ed
.Pp
Deriving keys from input key material:
.Bd -literal -offset indent
uint8_t okm [64];                 /* Output keys       */
uint8_t ikm [32];                 /* Input key material */
uint8_t salt[16];                 /* Random salt        */
uint8_t info[11] = "Lorem ipsum"; /* Domain separation  */
crypto_random(salt, sizeof(salt));
if (crypto_sha256_hkdf_checked(okm, sizeof(okm),
                               ikm, sizeof(ikm),
                               salt, sizeof(salt),
                               info, sizeof(info)) != CRYPTO_OK) {
	/* Abort on invalid inputs */
}
.Ed
.Sh SEE ALSO
.Xr crypto_blake2b 3monocypher ,
.Xr crypto_blake3 3monocypher ,
.Xr crypto_argon2 3monocypher ,
.Xr crypto_random 3monocypher ,
.Xr intro 3monocypher
.Sh CAVEATS
The unchecked variants do not perform input validation.
Any deviation from the specified input and output length ranges results
in
.Sy undefined behaviour .
For safer application code, use the checked variants.
.Sh STANDARDS
These functions implement SHA-256 as specified in FIPS 180-4.
